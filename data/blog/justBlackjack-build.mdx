---
title: Simulating blackjack rounds with JavaScript
date: '2023-03-19'
tags: ['web-dev', 'front-end', 'justBlackjack', 'javascript']
draft: false
summary: 'How blackjack rounds were simulated in JavaScript for justBlackjack'
authors: ['darrenwong']
---

<TOCInline toc={props.toc} indentDepth={2} />

# Introduction
I’m someone who believes in the power of experiential learning, that the best way to learn something is to do it yourself. So, when I needed to learn JavaScript for the purposes of front-end web development, I decided to tackle a small project - building a browser-based blackjack game. This was also highly inspired by an incredible JavaScript starter project, Universal Paperclips. The goal of this project was to develop a simple, fast-paced environment in which anyone could learn to play blackjack well without risking real money. The project was titled ‘justBlackjack’ to reflect the intended simplicity and focus on core gameplay.

This will be a two-post series to avoid either post being too long. In this post, I’ll step through the setup for this project by discussing:

- An overview of the rules of blackjack 
- The HTML and CSS structure of the project

In the next post, I’ll go through:

- How each of the main blackjack components were implemented in JavaScript; and,
- Next steps for the project.

Links before we get started:

- [justBlackjack](https://wongd-hub.github.io/justBlackjack/)
- [Repository](https://github.com/wongd-hub/justBlackjack)

# Overview of Blackjack Rules
Before moving to the technical aspects of this project, let’s quickly review the rules of this classic and popular card game.

The game begins with each player - the player and the dealer - receiving two cards. Each hand's value is determined by adding the values of each card. Face cards are worth 10 points, numbered cards are worth their pip value, and aces can be worth 1 or 11 points.

The objective of the game is to get as close to a total value of 21 points as possible without going over. The player will draw cards from the deck (called the 'shoe') until they decide to stop, with each draw being referred to as a 'hit'. Once the player decides to stop drawing cards, the dealer will hit until they have a total value of at least 17.

If a player's total goes over 21, they ‘bust’ or lose. If the dealer's total goes over 21, they bust and the player wins. If neither goes over 21, the player whose total is closest to 21 wins.

To summarise, the dealer's hand, the player's hand, and the shoe are the key entities in blackjack. The goal is to hit until the sum value is as close to 21 as possible without going over.

This is, of course, a simplified version of the rules. Further extensions will be introduced  where relevant, however we won’t discuss the deeper concepts such as splitting, doubling, or insurance in this post. Let’s move on to the next section, where we discuss implementing the visual aspects of blackjack in the browser.

# Page Visuals
In this section, I'll provide an overview of the HTML and CSS underlying justBlackjack to create a simple and visually appealing browser-based blackjack game. While the focus of this project is on the JavaScript implementation of the game mechanics, the visual elements are also important in creating an engaging user experience. Using HTML and CSS, we’ll attempt to structure and style the game interface to make it intuitive and easy to use, while also providing visual cues to the player during the game to enhance their playing and learning experience.

![Full screenshot](/static/images/justblackjack/full-screenshot.png)

The entire site is contained within a div with the id of `'website-body'`, and components within this div are organised with CSS Grid. Grid suits our purposes here since it allows for precise placement of items on the page in a 2D layout.

All of the sub-components, such as the player’s and dealer’s hands, title bar, and rules sidebar, are contained in separate divs and placed as children within the main div. This approach was chosen for better organisation and ease of positioning within the Grid. This also makes it easier to re-position the components for the mobile layout which is handled using CSS media queries. 

See the basic structure of the HTML below, note that some contents are omitted for brevity.

<details>
  <summary>justBlackjack HTML structure</summary>
  
  ```html:index.html {5, 10, 14, 18, 26, 30, 34}
    <body>

        <div class="website-body">
            <div class="title-bar">
                <!-- Title bar contents -->
            </div>
            <div class="side-bar">
                <h2 class="rules">rule_set</h2>
                <ul id="rule-set">
                    <!-- Responsive list of blackjack rules -->
                </ul>
            </div>
            <div class="quick-settings-box">
                <!-- Info in bottom left -->
            </div>
            <div class="player-cards" id="player-cards"></div>
            <div class="player-options">
                <!-- Player option buttons -->
                <p id="hit-button">hit</p>
                <p id="stand-button">stand</p>
                ...
            </div>
            <div class="dealer-cards" id="dealer-cards"></div>
            <div class="console" id="console">
                <div class="console-container" id="console-container">
                    <!-- Console in bottom right -->
                </div>
            </div>
            <div class="shoe">
                <!-- Shoe graphic and score counter -->
            </div>
        </div>

        <!-- Calling scripts -->
        <script src="./cardList.js"></script>
        <script src="./main.js"></script>

    </body>
    ```
</details>

The choice of colour scheme was inspired by the Tomorrow Night 80's theme which I was introduced to through R Studio. To ensure the proper rendering of ASCII art, a monospace font was used throughout the project.

![Colour palette](/static/images/justblackjack/colour-palette.png)

## Cards

```
  _____    _____    _____    _____    _____    _____    _____
 |2    |  |4    |  |6    |  |A .  |  |Q  ww|  |K  WW|  |\ ~ /|
 |  v  |  | ^ ^ |  | o o |  | /.\ |  | o {(|  |   {)|  |}}:{{|
 |     |  |     |  | o o |  |(_._)|  |o o%%|  |(v)%%|  |}}:{{|
 |  v  |  | ^ ^ |  | o o |  |  |  |  | |%%%|  | v%%%|  |}}:{{|
 |____2|  |____4|  |____6|  |____A|  |_%%%Q|  |_%%%K|  |/_~_\|

```

The cards on the website are represented using ASCII art sourced from [asciiart.eu](https://www.asciiart.eu/miscellaneous/playing-cards). To make the pip numbers more visible, each pip number is nested within a span with the class `'col-emphasis'` and styled using CSS. Additionally, to indicate that the cards are dynamic, the pip numbers fade on mouseover. This effect is achieved using a `:hover` CSS selector, which reduces the opacity of the pip numbers when the cursor hovers over them. Overall, this simple design provides players with a clean and visually appealing representation of the cards in the game.

```js:cardList.js
const cardList = [
    // [...]
    {
        cardName: 'Aspades',
        cardEntity: ` _____ <br>|<span>A</span> .  |<br>| /.\\ |<br>|(_._)|<br>|  |  |<br>|____<span>A</span>|`
    },
    {
        cardName: '2spades',
        cardEntity:` _____ <br>|<span>2</span>    |<br>|  ^  |<br>|     |<br>|  ^  |<br>|____<span>2</span>|`
    },
    // [...]
]
```

The card entities as well as their string representations are stored in an array of objects (`cardList`). To assist with drawing these to the screen, I’ve written two convenience functions:

- `prepCardStringForHTML()`: When passed a card item from `cardList`, this function takes the corresponding ASCII art string and reformats the HTML to print correctly on the site. It also utilises [regex](https://www.rexegg.com/) to add the class `‘col-emphasis’` to spans that contain the pip values so that we can target their text colour using CSS.

<details>
  <summary>Code block</summary>

    ```js:cardList.js
    function prepCardStringForHTML(
        cardElement, 
        // [...]
    ) {
        // [...]

            // Replace any spaces with the non-breaking space HTML entity
            var tmp = cardElement.replace(/\s/g, '&nbsp;');

            // Add class 'col-emphasis' to the first instance of a <span> in each card's string 
            var t = 0;
            var tmp_1 = tmp.replace(/<span>/g, match => ++t === 1 ? '<span class="col-emphasis">' : match)
                    // Add further 'bottom-pip' class to the second <span> for now deprecated additional styling
                    .replace(/<span>/g, '<span class="col-emphasis bottom-pip">');
        
            return tmp_1;

        // [...]
    }
    ```
</details>

- `drawCardStack()`: We need to be able to draw stacks of cards for when a player’s hand goes over two cards. Ideally we’d be able to quickly see the pip value of every card in the stack as well. This function makes use of JavaScript loops (as well as `map()`-ing over each element in an array) to take multiple card elements and plot them in a diagonal stack, with all cards under the top one showing the first three characters of their card.

![Screenshot of card stack](/static/images/justblackjack/card-screenshot.png)

<details>
  <summary>Code block</summary>

    ```js:cardList.js
    function drawCardStack(hand, orient = 'row', removeLastNCards = 0) {
        
        // This is used to leave out the newest card in the hand,
        // this card will be shown separately
        var handTmp = hand.slice(0, hand.length - removeLastNCards);

        // If there's only one card to stack, no action required
        if (handTmp.length === 1) {return null}

        // This function returns the visible characters of the ASCII art
        // for cards that are under the top card in the stack
        function pullFirstThreeChars(hand, index, orient = 'row') { 
            return cardList
                // Query cardList for ASCII string and split by newline 
                // into list of strings 
                .filter(obj => {return obj.cardName === hand[index].value + hand[index].suit})[0]
                .cardEntity
                .split('<br>')
                // For each line of ASCII art, pull the right number 
                // of characters
                .map(function(el, i) { 
                    if (i === 0 && orient === 'diag') {
                        // If a diagonal stack, the full first line of 
                        // the card is visible
                        return el
                    } else if (i === 1) {
                        // The second line of the card includes a span 
                        // element, so to capture the first 3 letters of 
                        // the second line, we need to account for the
                        // extra characters this tag adds. e.g. for an 
                        // ace of spades, this is what is captured: 
                        //   '|<span>A</span> '
                        return el.slice(0, 16)
                    } else {
                        // Otherwise, return the first 3 characters of 
                        // the line as normal
                        return el.slice(0, 3)
                    }
                });
        }

        if (orient === 'row) {

            // [...]

        } else if (orient === 'diag') {

            // Get the visible characters of the card at the bottom of
            // the stack. The remaining card characters will be appended
            // to this
            var leftSides = pullFirstThreeChars(handTmp, 0, 'diag');

            // For each card between the first and the last in the stack...
            for (let j = 1; j <= handTmp.length - 2; j++) {
                // ... get visible characters
                var toAdd = pullFirstThreeChars(handTmp, j, 'diag');
                
                // ... then add the contents of each card to the lines 
                // currently in leftSides, starting further down by one
                // line for each new card in the hand creating a diagonal 
                // cascading effect. 
                var len = leftSides.length;
                for (let k = 0; k <= len; k++) { 
                    if (k >= j && k <= len - 1) {
                        leftSides[k] = leftSides[k] + toAdd[k - j];
                    } else if (k === len) {
                        leftSides[k] = '   '.repeat(j) + toAdd[k - j];
                    }    
                }
            }

            // Add the full contents of the final card on top 
            var finalCard = cardList
                .filter(obj => {return obj.cardName === handTmp[handTmp.length - 1].value + handTmp[handTmp.length - 1].suit})[0]
                .cardEntity
                .split('<br>');

            var len = leftSides.length;
            for (let j = 0; j <= len; j++) { 
                if (j >= handTmp.length - 1 && j <= len - 1) {
                    leftSides[j] = leftSides[j] + finalCard[j - handTmp.length + 1];
                } else if (j === len) {
                    leftSides[j] = '   '.repeat(handTmp.length - 1) + finalCard[j - handTmp.length + 1];
                }    
            }

            // This output is then run through prepCardStringForHTML()
            // to ensure that pips are properly styled with the 
            // appropriate colour.
            return leftSides.join('<br>');

        }

    }
    ```
</details>
<br />
# Javascript Blackjack Implementation
...
## Learning and game tools
...
### Responsive rule set

```js:main.js
// Initiate rule switches
var ruleSet = {
    'face-rule': false, 
    'ace-rule': false, 
    'split-rule': false, 
    'double-rule': false, 
    'insurance-rule': false, 
    'split-max-rule': false
}

// [...]

function introduceRule(rule, styleClass) {
    if (!ruleSet[styleClass]) {
        document.getElementById('rule-set').innerHTML += `<li id="${styleClass}" class="${styleClass}">${rule}</li>`;
        document.getElementById(styleClass).style.visibility = 'visible';
        fadeIn(document.getElementById(styleClass)); // Another convenience function defined in main.js
        ruleSet[styleClass] = true;

        // Also add to mobile list
        document.getElementById('rule-2').innerHTML += `<li id="${styleClass + '2'}" class="${styleClass}">${rule}</li>`;
        document.getElementById(styleClass + '2').style.visibility = 'visible';
    }

    // If multiple rules are introduced at once, the interval will mess up;
    //  bandaid fix is to catch any rules that have no opacity and assign the correct opacity
    document.querySelectorAll('li[class*=\'-rule\']').forEach(function(x) {if (x.style.opacity === '') { x.style.opacity = 1 }});

}

// [...]

// Usage example
introduceRule('face cards are worth <span class="col-emphasis">10</span>', 'face-rule')
```

